/*
quartzcron (v.0.0.43)
*/
const C=require('./constants.js');const utils=require('./utils.js');const doubleDigitize=d=>{return d < 10 ? `0${d}`:d;};const digIt=({o, key, pre, post, atSingle, atMultiple, between, every, everys, lu})=>{const target=o[key];let mat, spl;mat=target.match(C.rx.loose.n);if(mat){return[...pre, atSingle(mat), ...post].join('');}mat=target.match(C.rx.loose['n-n']);if(mat){return[...pre, every(), ' ', between(mat), ...post].join('');}spl=target.split(',');mat=spl.every(i=> i.match(C.rx.loose.n));if(mat){return[...pre, atMultiple(spl), ...post].join('');}mat=target.match(C.rx.loose['n-n/n']);if(mat){return[...pre, everys(mat[3]), ' ', between(mat), ...post].join('');}spl=target.split(',');mat=spl.map(i=> i.match(C.rx.loose['nORn/n'])).filter(Boolean);if(mat.length===spl.length){const mid=mat.reduce((acc, m)=>{if(typeof m[2]==='undefined'){const start=parseInt(m[3], 10), cadence=parseInt(m[4], 10);acc.res.push([everys(cadence), lu.startingFrom(start)].join(' '))}else{const v=parseInt(m[1], 10);if(!acc.pres.includes(v)){acc.res.unshift(lu.atX(v))acc.pres.push(v)}}return acc;},{res:[], pres:[]});return[...pre, lu.multiple([...new Set(mid.res)]), ...post].join('');}};const describeTime=({s, i, h}, lu)=>{const sMatch=s.match(C.rx.loose.n), iMatch=i.match(C.rx.loose.n), hMatch=h.match(C.rx.loose.n), sEvery=s==='*', iEvery=i==='*', hEvery=h==='*';let mat, spl;if(sMatch && iMatch && hMatch){const _s=parseInt(sMatch[0]), _i=parseInt(iMatch[0]), _h=parseInt(hMatch[0]);return lu.atX(`${doubleDigitize(_h)}:${doubleDigitize(_i)}:${doubleDigitize(_s)}`);}if(hEvery){if(iEvery){if(sEvery){return lu.everyX(lu.second);}else{return digIt({o:{s, i, h}, key:'s', pre:[], post:[lu.comma, ' ', lu.everyX(lu.minute)], every:()=> lu.everyX(lu.second), everys:m=> lu.everyX(m, lu.seconds), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.second), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.seconds), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu});}}else{if(sEvery){return digIt({o:{s, i, h}, key:'i', pre:[lu.everyX(lu.second), lu.comma, ' ',], post:[], every:()=> lu.everyX(lu.minute), everys:m=> lu.everyX(m, lu.minutes), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.minute), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.minutes), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu});}else{return[digIt({o:{s, i, h}, key:'s', pre:[], post:[], every:()=> lu.everyX(lu.second), everys:m=> lu.everyX(m, lu.seconds), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.second), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.seconds), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu}), digIt({o:{s, i, h}, key:'i', pre:[], post:[], every:()=> lu.everyX(lu.minute), everys:m=> lu.everyX(m, lu.minutes), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.minute), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.minutes), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu})].join(', ');}}}else{if(iEvery){if(sEvery){return digIt({o:{s, i, h}, key:'h', pre:[lu.everyX(lu.second), ', ',], post:[], every:()=> lu.everyX(lu.hour), everys:m=> lu.everyX(m, lu.hours), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.hour), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.hours), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu});}else{return[digIt({o:{s, i, h}, key:'s', pre:[], post:[], every:()=> lu.everyX(lu.second), everys:m=> lu.everyX(m, lu.seconds), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.second), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.seconds), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu}), digIt({o:{s, i, h}, key:'h', pre:[lu.everyX(lu.minute), ', '], post:[], every:()=> lu.everyX(lu.hour), everys:m=> lu.everyX(m, lu.hours), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.hour), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.hours), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu})].join(', ');}}else{if(sEvery){return[digIt({o:{s, i, h}, key:'i', pre:[lu.everyX(lu.second), ', '], post:[], every:()=> lu.everyX(lu.minute), everys:m=> lu.everyX(m, lu.minutes), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.minute), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.minutes), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu}), digIt({o:{s, i, h}, key:'h', pre:[], post:[], every:()=> lu.everyX(lu.hour), everys:m=> lu.everyX(m, lu.hours), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.hour), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.hours), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu})].join(', ');}else{return[digIt({o:{s, i, h}, key:'s', pre:[], post:[], every:()=> lu.everyX(lu.second), everys:m=> lu.everyX(m, lu.seconds), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.second), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.seconds), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu}), digIt({o:{s, i, h}, key:'i', pre:[], post:[], every:()=> lu.everyX(lu.minute), everys:m=> lu.everyX(m, lu.minutes), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.minute), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.minutes), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu}), digIt({o:{s, i, h}, key:'h', pre:[], post:[], every:()=> lu.everyX(lu.hour), everys:m=> lu.everyX(m, lu.hours), atSingle:mat=> lu.atX(doubleDigitize(mat[1]), lu.hour), atMultiple:spl=> lu.atMultipX(spl.map(doubleDigitize), lu.hours), between:mat=> lu.betweenXY(doubleDigitize(mat[1]), doubleDigitize(mat[2])), lu})].join(', ');}}}}, describeDomDowOccurrence=({h,i,s, dom, dow, m, y}, lu)=>{const mEvery=m==='*', yEvery=y==='*';if((dow==='*' && dom==='?')||(dom==='*' && dow==='?')){if(h==='*' || i==='*' || s==='*')return '';return lu.everyX(lu.day);}let mat, spl;if(!dom.match(/^[*?]$/)){mat=dom.match(C.rx.ranged.md);if(mat){return[lu.inMonthDay(mat[0]), mEvery && lu.everyX(lu.month)].filter(Boolean).join(', ');}mat=dom.match(C.rx.ranged['md/md']);if(mat){return[lu.everyStartingFrom(mat[1], mat[2], lu.day), mEvery && lu.everyX(lu.month)].filter(Boolean).join(', ');}mat=dom.match(C.rx.ranged['md-md']);if(mat){return[lu.betweenMonthDays(mat[1], mat[2], lu.day), mEvery && lu.everyX(lu.month)].filter(Boolean).join(', ');}mat=dom.match(C.rx.ranged['md-md/md']);if(mat){return[lu.everyX(mat[3], lu.days), ' ', lu.betweenMonthDays(mat[1], mat[2], lu.day), ', ', mEvery && lu.everyX(lu.month)].filter(Boolean).join('');}spl=dom.split(',');mat=spl.every(s=> s.match(C.rx.ranged['md']));if(mat){return[lu.multipleTheL(spl, lu.day), ', ', mEvery && lu.everyX(lu.month)].filter(Boolean).join('');}mat=dom.match(C.rx.dumb.L);if(mat){return[lu.onThe(lu.last, lu.day), lu.ofTheX(lu.month)].join(' ');}mat=dom.match(C.rx.dumb.LW);if(mat){return[lu.onThe(lu.last, lu.weekday), lu.ofTheX(lu.month)].join(' ');}mat=dom.match(C.rx.ranged['mdW']);if(mat){return[lu.nearestToThe(lu.weekday, mat[1]), lu.ofTheX(lu.month)].join(' ');}mat=dom.match(C.rx.ranged['L-md']);if(mat){const n=parseInt(mat[1], 10), L=n > 1 ? lu.days:lu. day;return[lu.nX(mat[1], L), lu.beforeTheEndOfThe(lu.month)]. join(' ');}spl=dom.split(/,/);mat=spl.map(s=> s.match(C.rx.ranged['mdORmd/md'])).filter(Boolean);if(spl.length===mat.length){let collect=mat.reduce((acc, m)=>{let v2=parseInt(m[2], 10);if(typeof m[2]!=='undefined'){if(!acc.plain.includes(v2))acc.plain.push(v2);}else{let start=parseInt(m[3], 10);const every=parseInt(m[4], 10);acc.mixed.push([lu.everyX(every, lu.days), lu.startingFrom(lu.thize(start))].join(' '))}return acc;},{plain:[], mixed:[]});return[collect.plain.length && lu.multipleThe(collect.plain), collect.mixed.length && lu.multiple(collect.mixed)].filter(Boolean).join('')}}if(!dow.match(C.rx.dumb.astrxQuest)){const numDow=utils.daysLabels2Numbers(dow);mat=numDow.match(C.rx.dumb.weekend);if(mat){return lu.everyX(lu.weekend);}mat=numDow.match(C.rx.dumb.weekday);if(mat){return lu.everyX(lu.weekday);}mat=numDow.match(C.rx.ranged['wdOR*/wd']);if(mat){const fromFirstWd=mat[1]==='*' ? 1:parseInt(mat[1], 10), step=parseInt(mat[2]);if(fromFirstWd+step > 7){return lu.everyX(lu.weekdaysNames[fromFirstWd-1]);}return[step > 1 ? lu.everyX(step, lu.days):lu.everyX(lu.day), lu.ofTheX(lu.week), lu.startingOn(lu.weekdaysNames[fromFirstWd-1])].join(' ');}spl=numDow.split(C.rx.dumb.comma);mat=spl.map(s=> s.match(C.rx.ranged['wdORwd/wd'])).filter(Boolean);if(spl.length===mat.length){const max=7;let collect=mat.reduce((acc, m)=>{let v2=parseInt(m[2], 10);if(typeof m[2]!=='undefined'){acc.push(v2)}else{let cursor=parseInt(m[3], 10);const every=parseInt(m[4], 10);while(cursor <=max){acc.push(cursor);cursor=every+cursor;}}return acc;},[]).sort((a,b)=> a > b ? 1:-1);return lu.multipleDays(collect.map(c=> lu.weekdaysNames[c-1]))}mat=numDow.match(C.rx.ranged['wd-wd']);if(mat){const start=parseInt(mat[2], 10), end=parseInt(mat[3], 10);return lu.betweenXY(lu.weekdaysNames[start-1], lu.weekdaysNames[end-1]);}mat=numDow.match(C.rx.ranged['wd-wd/wd']);if(mat){const start=parseInt(mat[2], 10), end=parseInt(mat[3], 10), cadence=parseInt(mat[4], 10);return[cadence > 1 ? lu.everyX(cadence, lu.days):lu.everyX(lu.day), lu.betweenXY(lu.weekdaysNames[start-1], lu.weekdaysNames[end-1]),].join(' ')}mat=numDow.match(C.rx.ranged['wdL']);if(mat){return lu.onLast(lu.weekdaysNames[parseInt(mat[1], 10)-1], lu.ofTheX(lu.month))}mat=numDow.match(C.rx.ranged['wd#wdn']);if(mat){return[lu.onTheNth(parseInt(mat[2], 10), lu.weekdaysNames[parseInt(mat[1], 10)-1]), lu.ofTheX(lu.month)].join(' ')}}}, describeMonthsYears=({y, m, dom, dow}, lu)=>{const yMatch=y.match(C.rx.loose.n), mMatch=m.match(C.rx.loose.n), yEvery=y==='*', mEvery=m==='*';if(yMatch && mMatch){const _y=parseInt(yMatch[0]), _m=parseInt(mMatch[0]);return[lu.inX(lu.monthsNames[_m-1]), _y,].join(' ');}if(yEvery){if(mEvery){return '';}else{return digIt({o:{y, m}, key:'m', pre:[], post:[], every:()=> lu.everyX(lu.month), everys:m=> lu.everyX(m, lu.months), atSingle:mat=> lu.inX(lu.monthsNames[parseInt(mat[1], 10)-1]), atMultiple:spl=> lu.inMultipX(spl.map(m=> lu.monthsNames[parseInt(m, 10)-1])), between:mat=> lu.betweenXY(lu.monthsNames[parseInt(mat[1], 10)-1], lu.monthsNames[parseInt(mat[2], 10)-1]), lu});}}else{if(mEvery){return digIt({o:{y, m}, key:'y', pre:[], post:[], every:()=> lu.everyX(lu.year), everys:m=> lu.everyX(m, lu.years), atSingle:mat=> lu.inX(mat[1]), atMultiple:spl=> lu.inMultipX(spl), between:mat=> lu.betweenXY(mat[1], mat[2]), lu});}else{return[digIt({o:{y, m}, key:'m', pre:[], post:[], every:()=> lu.everyX(lu.month), everys:m=> lu.everyX(m, lu.months), atSingle:mat=> lu.inX(lu.monthsNames[parseInt(mat[1], 10)-1]), atMultiple:spl=> lu.inMultipX(spl.map(m=> lu.monthsNames[parseInt(m, 10)-1])), between:mat=> lu.betweenXY(lu.monthsNames[parseInt(mat[1], 10)-1], lu.monthsNames[parseInt(mat[2], 10)-1]), lu}), digIt({o:{y, m}, key:'y', pre:[], post:[], every:()=> lu.everyX(lu.year), everys:m=> lu.everyX(m, lu.years), atSingle:mat=> mat[1], atMultiple:spl=> lu.inMultipX(spl), between:mat=> lu.betweenXY(mat[1], mat[2]), lu})].join(', ');}}};const describe=(els, lu)=>{return[describeTime(els, lu), describeDomDowOccurrence(els, lu), describeMonthsYears(els, lu)].filter(Boolean).join(', ');};module.exports={describe}